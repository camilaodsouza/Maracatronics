/*
 * Protocolo de comunicacao
 * [M][ID][Flags][V1][V2][V3][CRCHi][CRCLo]
 * [Flags]=b [XXXX HCCD]
 * recebe do Sumatra [id][XXXX XCCD][V1][V2][V3]
 */

//bibliotecas do radio
#include <Enrf24.h>
#include <nRF24L01.h>
#include <string.h>
#include <SPI.h>

#define PROTOCOL_SIZE 6
#define START_BYTE 0x4D

#define Led_Aux PF_0

#define HORUS_BIT 0x08
#define CHANNEL 10



 const byte _auchCRCHi[] = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
  0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
  0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
  0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
  0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
  0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
  0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
  0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
  0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
  0x40};

/* Table of CRC values for low�order byte */
const byte _auchCRCLo[] = {
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
  0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
  0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
  0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
  0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
  0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
  0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
  0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
  0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
  0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
  0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
  0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
  0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
  0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
  0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
  0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
  0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
  0x40};



Enrf24 radio(PD_1, PC_4, PC_5); //PD_1: CE   PC_4: CSN   PC_5:IRQ
const uint8_t txaddr[] = {0x11, 0x22, 0x33, 0x44, 0x55};



byte protocol[PROTOCOL_SIZE];
const int number_of_bytes=PROTOCOL_SIZE+2;
int i=0, timer=0;
unsigned long horus_timer=0;
boolean state = false,horus_bit=false, prev_horus_bit=false;




void Status_do_radio_serial(uint8_t status);
void enviar_pacote (byte* frame);
word calcCrc(byte address, byte* pduFrame, byte pduLen);




void setup()
{
  pinMode(RED_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);

  Serial.begin(38400);

  SPI.begin();
  SPI.setDataMode(SPI_MODE0);
  SPI.setBitOrder(MSBFIRST);           //MSB primeiro
  SPI.setModule(3);         //seleciona o modulo de SPI 3 do micro
  
  radio.begin();  //padrões 1Mbps, canal 0, max TX power
  Status_do_radio_serial(radio.radioState());


  radio.setChannel(CHANNEL);
  radio.setTXaddress((void*)txaddr);

  horus_timer=millis();
}

void loop()
{

  if(horus_timer-millis()>=250){
    horus_bit=!horus_bit;
  }

  if (radio.radioState() == ENRF24_STATE_NOTPRESENT) {
    Serial.println("erro no radio");
    digitalWrite(GREEN_LED, LOW);
    digitalWrite(BLUE_LED, LOW);
    digitalWrite(RED_LED, HIGH);
  }

  else {

    if (Serial.available()) {

      digitalWrite(BLUE_LED, LOW);
      digitalWrite(RED_LED, LOW);

      char a = Serial.read();
      if(a==0){
        a=1;
      }
      protocol[i] = a;
      
      if (protocol[0]==START_BYTE){
        i++;
      }
      timer = 0;
      
      

      if (i >= PROTOCOL_SIZE)
      {
//        for(int j=0;j<PROTOCOL_SIZE;j++){
//          Serial.write(&protocol[j],1);
//        }
        enviar_pacote(protocol);
        i = 0;
        state=!state;
        digitalWrite(GREEN_LED, state);
      }
    }//end if do serial available

    else {
      digitalWrite(RED_LED, LOW);

      if (timer <= 1000){
        timer++;
      }
      else{
        digitalWrite(BLUE_LED, HIGH);
        digitalWrite(GREEN_LED, LOW);
      }
    }

  }//end else do estado do radio

} //end loop




void enviar_pacote (byte* frame){
        byte protocol_aux[PROTOCOL_SIZE-2];
        char send_frame [number_of_bytes];
        
         
        
        //Montar o frame de envio
        send_frame[0]=frame[0];           //START byte M
        send_frame[1]=frame[1];    //ID do Robo

        for(int j=0;j<PROTOCOL_SIZE-2;j++){
          protocol_aux[j]=frame[j+2];
          send_frame[j+2]=protocol_aux[j];
        }


        if(horus_bit!=prev_horus_bit){
         // send_frame[2]=send_frame[2]|HORUS_BIT;
          prev_horus_bit=horus_bit;
        }

        u_int crc=calcCrc(frame[1],protocol_aux,PROTOCOL_SIZE-1);
        byte crclo=crc&0xFF;
        byte crchi=(crc>>8)&0xFF;

        send_frame[number_of_bytes-2]=crchi;
        send_frame[number_of_bytes-1]=crclo;


          for(int j=0;j<number_of_bytes;j++){
          Serial.write(&send_frame[j],1);
        }




        //enviar o frame
        radio.print(send_frame);
        radio.flush();
        delay(5);
        
}


word calcCrc(byte address, byte* pduFrame, byte pduLen) {
    byte CRCHi = 0xFF, CRCLo = 0x0FF, Index;

    Index = CRCHi ^ address;
    CRCHi = CRCLo ^ _auchCRCHi[Index];
    CRCLo = _auchCRCLo[Index];

    while (pduLen--) {
      Index = CRCHi ^ *pduFrame++;
      CRCHi = CRCLo ^ _auchCRCHi[Index];
      CRCLo = _auchCRCLo[Index];
    }

    return (CRCHi << 8) | CRCLo;
  }


void Status_do_radio_serial(uint8_t status)
{
  Serial.print("Enrf24 radio transceiver status: ");
  switch (status) {
    case ENRF24_STATE_NOTPRESENT:
      Serial.println("NO TRANSCEIVER PRESENT");
      break;

    case ENRF24_STATE_DEEPSLEEP:
      Serial.println("DEEP SLEEP <1uA power consumption");
      break;

    case ENRF24_STATE_IDLE:
      Serial.println("IDLE module powered up w/ oscillators running");
      break;

    case ENRF24_STATE_PTX:
      Serial.println("Actively Transmitting");
      break;

    case ENRF24_STATE_PRX:
      Serial.println("Receive Mode");
      break;

    default:
      Serial.println("UNKNOWN STATUS CODE");
  }
}

